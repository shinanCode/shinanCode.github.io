import{_ as e,c as t,o as a,a4 as o}from"./chunks/framework.Bkp5Egd4.js";const f=JSON.parse('{"title":"双向数据绑定","description":"","frontmatter":{},"headers":[],"relativePath":"vue/双向数据绑定.md","filePath":"vue/双向数据绑定.md","lastUpdated":null}'),r={name:"vue/双向数据绑定.md"},c=o('<h1 id="双向数据绑定" tabindex="-1">双向数据绑定 <a class="header-anchor" href="#双向数据绑定" aria-label="Permalink to &quot;双向数据绑定&quot;">​</a></h1><h2 id="vue2-双向数据绑定" tabindex="-1">Vue2 双向数据绑定 <a class="header-anchor" href="#vue2-双向数据绑定" aria-label="Permalink to &quot;Vue2 双向数据绑定&quot;">​</a></h2><p>采用<code>数据劫持</code>结合<code>订阅者-发布者模式</code>的方式，data数据在初始化的时候，会实例化一个<code>Observe</code>类，将data数据进行递归遍历，并通过<code>Object.defineProperty</code>方法，给每个值添加一个getter和setter。数据杜族的时候触发getter进行依赖收集，当数据发生改变，出发setter，对刚刚收集的依赖进行触发，并且更新<code>watcher</code>通知视图渲染。</p><h3 id="object-defineproperty-缺点" tabindex="-1">Object.defineProperty() 缺点 <a class="header-anchor" href="#object-defineproperty-缺点" aria-label="Permalink to &quot;Object.defineProperty() 缺点&quot;">​</a></h3><p>该方法只能监听到数据的修改，监听不到数据的新增和删除，从而不出发组件的更新渲染。vue3 对数据的新增删除方法重写，在拦截里进行手动手机触发依赖更新。</p>',5),d=[c];function n(_,s,i,l,p,h){return a(),t("div",null,d)}const b=e(r,[["render",n]]);export{f as __pageData,b as default};
